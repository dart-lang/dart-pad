{
  "version": 3,
  "sources": ["src/flutter.js"],
  "sourcesContent": ["// Copyright 2013 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nvar _flutter = window._flutter;\nif (!_flutter) {\n  _flutter = window._flutter = {};\n}\n_flutter.loader = null;\n\n(function () {\n  \"use strict\";\n\n  const baseUri = ensureTrailingSlash(getBaseURI());\n\n  function getBaseURI() {\n    const base = document.querySelector(\"base\");\n    return (base && base.getAttribute(\"href\")) || \"\";\n  }\n\n  function ensureTrailingSlash(uri) {\n    if (uri == \"\") {\n      return uri;\n    }\n    return uri.endsWith(\"/\") ? uri : `${uri}/`;\n  }\n\n  /**\n   * Wraps `promise` in a timeout of the given `duration` in ms.\n   *\n   * Resolves/rejects with whatever the original `promises` does, or rejects\n   * if `promise` takes longer to complete than `duration`. In that case,\n   * `debugName` is used to compose a legible error message.\n   *\n   * If `duration` is < 0, the original `promise` is returned unchanged.\n   * @param {Promise} promise\n   * @param {number} duration\n   * @param {string} debugName\n   * @returns {Promise} a wrapped promise.\n   */\n  async function timeout(promise, duration, debugName) {\n    if (duration < 0) {\n      return promise;\n    }\n    let timeoutId;\n    const _clock = new Promise((_, reject) => {\n      timeoutId = setTimeout(() => {\n        reject(\n          new Error(\n            `${debugName} took more than ${duration}ms to resolve. Moving on.`,\n            {\n              cause: timeout,\n            }\n          )\n        );\n      }, duration);\n    });\n\n    return Promise.race([promise, _clock]).finally(() => {\n      clearTimeout(timeoutId);\n    });\n  }\n\n  /**\n   * Handles the creation of a TrustedTypes `policy` that validates URLs based\n   * on an (optional) incoming array of RegExes.\n   */\n  class FlutterTrustedTypesPolicy {\n    /**\n     * Constructs the policy.\n     * @param {[RegExp]} validPatterns the patterns to test URLs\n     * @param {String} policyName the policy name (optional)\n     */\n    constructor(validPatterns, policyName = \"flutter-js\") {\n      const patterns = validPatterns || [\n        /\\.js$/,\n      ];\n      if (window.trustedTypes) {\n        this.policy = trustedTypes.createPolicy(policyName, {\n          createScriptURL: function(url) {\n            const parsed = new URL(url, window.location);\n            const file = parsed.pathname.split(\"/\").pop();\n            const matches = patterns.some((pattern) => pattern.test(file));\n            if (matches) {\n              return parsed.toString();\n            }\n            console.error(\n              \"URL rejected by TrustedTypes policy\",\n              policyName, \":\", url, \"(download prevented)\");\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles loading/reloading Flutter's service worker, if configured.\n   *\n   * @see: https://developers.google.com/web/fundamentals/primers/service-workers\n   */\n  class FlutterServiceWorkerLoader {\n    /**\n     * Injects a TrustedTypesPolicy (or undefined if the feature is not supported).\n     * @param {TrustedTypesPolicy | undefined} policy\n     */\n    setTrustedTypesPolicy(policy) {\n      this._ttPolicy = policy;\n    }\n\n    /**\n     * Returns a Promise that resolves when the latest Flutter service worker,\n     * configured by `settings` has been loaded and activated.\n     *\n     * Otherwise, the promise is rejected with an error message.\n     * @param {*} settings Service worker settings\n     * @returns {Promise} that resolves when the latest serviceWorker is ready.\n     */\n    loadServiceWorker(settings) {\n      if (settings == null) {\n        // In the future, settings = null -> uninstall service worker?\n        console.debug(\"Null serviceWorker configuration. Skipping.\");\n        return Promise.resolve();\n      }\n      if (!(\"serviceWorker\" in navigator)) {\n        let errorMessage = \"Service Worker API unavailable.\";\n        if (!window.isSecureContext) {\n          errorMessage += \"\\nThe current context is NOT secure.\"\n          errorMessage += \"\\nRead more: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts\";\n        }\n        return Promise.reject(\n          new Error(errorMessage)\n        );\n      }\n      const {\n        serviceWorkerVersion,\n        serviceWorkerUrl = `${baseUri}flutter_service_worker.js?v=${serviceWorkerVersion}`,\n        timeoutMillis = 4000,\n      } = settings;\n\n      // Apply the TrustedTypes policy, if present.\n      let url = serviceWorkerUrl;\n      if (this._ttPolicy != null) {\n        url = this._ttPolicy.createScriptURL(url);\n      }\n\n      const serviceWorkerActivation = navigator.serviceWorker\n        .register(url)\n        .then((serviceWorkerRegistration) => this._getNewServiceWorker(serviceWorkerRegistration, serviceWorkerVersion))\n        .then(this._waitForServiceWorkerActivation);\n\n      // Timeout race promise\n      return timeout(\n        serviceWorkerActivation,\n        timeoutMillis,\n        \"prepareServiceWorker\"\n      );\n    }\n\n    /**\n     * Returns the latest service worker for the given `serviceWorkerRegistration`.\n     *\n     * This might return the current service worker, if there's no new service worker\n     * awaiting to be installed/updated.\n     *\n     * @param {ServiceWorkerRegistration} serviceWorkerRegistration\n     * @param {String} serviceWorkerVersion\n     * @returns {Promise<ServiceWorker>}\n     */\n    async _getNewServiceWorker(serviceWorkerRegistration, serviceWorkerVersion) {\n      if (!serviceWorkerRegistration.active && (serviceWorkerRegistration.installing || serviceWorkerRegistration.waiting)) {\n        // No active web worker and we have installed or are installing\n        // one for the first time. Simply wait for it to activate.\n        console.debug(\"Installing/Activating first service worker.\");\n        return serviceWorkerRegistration.installing || serviceWorkerRegistration.waiting;\n      } else if (!serviceWorkerRegistration.active.scriptURL.endsWith(serviceWorkerVersion)) {\n        // When the app updates the serviceWorkerVersion changes, so we\n        // need to ask the service worker to update.\n        const newRegistration = await serviceWorkerRegistration.update();\n        console.debug(\"Updating service worker.\");\n        return newRegistration.installing || newRegistration.waiting || newRegistration.active;\n      } else {\n        console.debug(\"Loading from existing service worker.\");\n        return serviceWorkerRegistration.active;\n      }\n    }\n\n    /**\n     * Returns a Promise that resolves when the `serviceWorker` changes its\n     * state to \"activated\".\n     *\n     * @param {ServiceWorker} serviceWorker\n     * @returns {Promise<void>}\n     */\n    async _waitForServiceWorkerActivation(serviceWorker) {\n      if (!serviceWorker || serviceWorker.state == \"activated\") {\n        if (!serviceWorker) {\n          throw new Error(\"Cannot activate a null service worker!\");\n        } else {\n          console.debug(\"Service worker already active.\");\n          return;\n        }\n      }\n      return new Promise((resolve, _) => {\n        serviceWorker.addEventListener(\"statechange\", () => {\n          if (serviceWorker.state == \"activated\") {\n            console.debug(\"Activated new service worker.\");\n            resolve();\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * Handles injecting the main Flutter web entrypoint (main.dart.js), and notifying\n   * the user when Flutter is ready, through `didCreateEngineInitializer`.\n   *\n   * @see https://docs.flutter.dev/development/platform-integration/web/initialization\n   */\n  class FlutterEntrypointLoader {\n    /**\n     * Creates a FlutterEntrypointLoader.\n     */\n    constructor() {\n      // Watchdog to prevent injecting the main entrypoint multiple times.\n      this._scriptLoaded = false;\n    }\n\n    /**\n     * Injects a TrustedTypesPolicy (or undefined if the feature is not supported).\n     * @param {TrustedTypesPolicy | undefined} policy\n     */\n    setTrustedTypesPolicy(policy) {\n      this._ttPolicy = policy;\n    }\n\n    /**\n     * Loads flutter main entrypoint, specified by `entrypointUrl`, and calls a\n     * user-specified `onEntrypointLoaded` callback with an EngineInitializer\n     * object when it's done.\n     *\n     * @param {*} options\n     * @returns {Promise | undefined} that will eventually resolve with an\n     * EngineInitializer, or will be rejected with the error caused by the loader.\n     * Returns undefined when an `onEntrypointLoaded` callback is supplied in `options`.\n     */\n    async loadEntrypoint(options) {\n      const { entrypointUrl = `${baseUri}main.dart.js`, onEntrypointLoaded, nonce } =\n        options || {};\n\n      return this._loadEntrypoint(entrypointUrl, onEntrypointLoaded, nonce);\n    }\n\n    /**\n     * Resolves the promise created by loadEntrypoint, and calls the `onEntrypointLoaded`\n     * function supplied by the user (if needed).\n     *\n     * Called by Flutter through `_flutter.loader.didCreateEngineInitializer` method,\n     * which is bound to the correct instance of the FlutterEntrypointLoader by\n     * the FlutterLoader object.\n     *\n     * @param {Function} engineInitializer @see https://github.com/flutter/engine/blob/main/lib/web_ui/lib/src/engine/js_interop/js_loader.dart#L42\n     */\n    didCreateEngineInitializer(engineInitializer) {\n      if (typeof this._didCreateEngineInitializerResolve === \"function\") {\n        this._didCreateEngineInitializerResolve(engineInitializer);\n        // Remove the resolver after the first time, so Flutter Web can hot restart.\n        this._didCreateEngineInitializerResolve = null;\n        // Make the engine revert to \"auto\" initialization on hot restart.\n        delete _flutter.loader.didCreateEngineInitializer;\n      }\n      if (typeof this._onEntrypointLoaded === \"function\") {\n        this._onEntrypointLoaded(engineInitializer);\n      }\n    }\n\n    /**\n     * Injects a script tag into the DOM, and configures this loader to be able to\n     * handle the \"entrypoint loaded\" notifications received from Flutter web.\n     *\n     * @param {string} entrypointUrl the URL of the script that will initialize\n     *                 Flutter.\n     * @param {Function} onEntrypointLoaded a callback that will be called when\n     *                   Flutter web notifies this object that the entrypoint is\n     *                   loaded.\n     * @returns {Promise | undefined} a Promise that resolves when the entrypoint\n     *                                is loaded, or undefined if `onEntrypointLoaded`\n     *                                is a function.\n     */\n    _loadEntrypoint(entrypointUrl, onEntrypointLoaded, nonce) {\n      const useCallback = typeof onEntrypointLoaded === \"function\";\n\n      if (!this._scriptLoaded) {\n        this._scriptLoaded = true;\n        const scriptTag = this._createScriptTag(entrypointUrl, nonce);\n        if (useCallback) {\n          // Just inject the script tag, and return nothing; Flutter will call\n          // `didCreateEngineInitializer` when it's done.\n          console.debug(\"Injecting <script> tag. Using callback.\");\n          this._onEntrypointLoaded = onEntrypointLoaded;\n          document.body.append(scriptTag);\n        } else {\n          // Inject the script tag and return a promise that will get resolved\n          // with the EngineInitializer object from Flutter when it calls\n          // `didCreateEngineInitializer` later.\n          return new Promise((resolve, reject) => {\n            console.debug(\n              \"Injecting <script> tag. Using Promises. Use the callback approach instead!\"\n            );\n            this._didCreateEngineInitializerResolve = resolve;\n            scriptTag.addEventListener(\"error\", reject);\n            document.body.append(scriptTag);\n          });\n        }\n      }\n    }\n\n    /**\n     * Creates a script tag for the given URL.\n     * @param {string} url\n     * @returns {HTMLScriptElement}\n     */\n    _createScriptTag(url, nonce) {\n      const scriptTag = document.createElement(\"script\");\n      scriptTag.type = \"application/javascript\";\n      if (nonce) {\n        scriptTag.nonce = nonce;\n      }\n      // Apply TrustedTypes validation, if available.\n      let trustedUrl = url;\n      if (this._ttPolicy != null) {\n        trustedUrl = this._ttPolicy.createScriptURL(url);\n      }\n      scriptTag.src = trustedUrl;\n      return scriptTag;\n    }\n  }\n\n  /**\n   * The public interface of _flutter.loader. Exposes two methods:\n   * * loadEntrypoint (which coordinates the default Flutter web loading procedure)\n   * * didCreateEngineInitializer (which is called by Flutter to notify that its\n   *                              Engine is ready to be initialized)\n   */\n  class FlutterLoader {\n    /**\n     * Initializes the Flutter web app.\n     * @param {*} options\n     * @returns {Promise?} a (Deprecated) Promise that will eventually resolve\n     *                     with an EngineInitializer, or will be rejected with\n     *                     any error caused by the loader. Or Null, if the user\n     *                     supplies an `onEntrypointLoaded` Function as an option.\n     */\n    async loadEntrypoint(options) {\n      const { serviceWorker, ...entrypoint } = options || {};\n\n      // A Trusted Types policy that is going to be used by the loader.\n      const flutterTT = new FlutterTrustedTypesPolicy();\n\n      // The FlutterServiceWorkerLoader instance could be injected as a dependency\n      // (and dynamically imported from a module if not present).\n      const serviceWorkerLoader = new FlutterServiceWorkerLoader();\n      serviceWorkerLoader.setTrustedTypesPolicy(flutterTT.policy);\n      await serviceWorkerLoader.loadServiceWorker(serviceWorker).catch(e => {\n        // Regardless of what happens with the injection of the SW, the show must go on\n        console.warn(\"Exception while loading service worker:\", e);\n      });\n\n      // The FlutterEntrypointLoader instance could be injected as a dependency\n      // (and dynamically imported from a module if not present).\n      const entrypointLoader = new FlutterEntrypointLoader();\n      entrypointLoader.setTrustedTypesPolicy(flutterTT.policy);\n      // Install the `didCreateEngineInitializer` listener where Flutter web expects it to be.\n      this.didCreateEngineInitializer =\n        entrypointLoader.didCreateEngineInitializer.bind(entrypointLoader);\n      return entrypointLoader.loadEntrypoint(entrypoint);\n    }\n  }\n\n  _flutter.loader = new FlutterLoader();\n})();\n"],
  "mappings": "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",
  "names": ["_flutter", "baseUri", "ensureTrailingSlash", "getBaseURI", "base", "uri", "timeout", "promise", "duration", "debugName", "timeoutId", "_clock", "_", "reject", "FlutterTrustedTypesPolicy", "validPatterns", "policyName", "patterns", "url", "parsed", "file", "pattern", "FlutterServiceWorkerLoader", "policy", "settings", "errorMessage", "serviceWorkerVersion", "serviceWorkerUrl", "timeoutMillis", "serviceWorkerActivation", "serviceWorkerRegistration", "newRegistration", "serviceWorker", "resolve", "FlutterEntrypointLoader", "options", "entrypointUrl", "onEntrypointLoaded", "nonce", "engineInitializer", "useCallback", "scriptTag", "trustedUrl", "FlutterLoader", "entrypoint", "flutterTT", "serviceWorkerLoader", "e", "entrypointLoader"]
}
