// Copyright (c) 2023, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// ignore_for_file: avoid_web_libraries_in_flutter

import 'dart:async';
import 'dart:html' as html;

import '../model.dart';

class ExecutionServiceImpl implements ExecutionService {
  final StreamController<String> _stdoutController =
      StreamController<String>.broadcast();

  html.IFrameElement _frame;
  late String _frameSrc;
  Completer<void> _readyCompleter = Completer();

  ExecutionServiceImpl(this._frame) {
    final src = _frame.src;
    if (src == null) {
      throw StateError('invalid iframe src');
    }
    _frameSrc = src;

    _initListener();
  }

  @override
  Future<void> execute(String javaScript) async {
    return _send('execute', {
      'js': _decorateJavaScript(javaScript),
    });
  }

  @override
  Stream<String> get onStdout => _stdoutController.stream;

  @override
  Future<void> reset() => _reset();

  @override
  Future<void> tearDown() => _reset();

  String _decorateJavaScript(String javaScript) {
    final completeScript = StringBuffer();

    // postMessagePrint:
    completeScript.writeln('''
function dartPrint(message) {
  parent.postMessage(
    {'sender': 'frame', 'type': 'stdout', 'message': message.toString()}, '*');  
}
''');

    // The JavaScript exception handling for DartPad catches both errors
    // directly raised by `main()` (in which case we might have useful Dart
    // exception information we don't want to discard), as well as errors
    // generated by other means, like assertion errors when starting up
    // asynchronous functions.
    //
    // To avoid duplicating error messages on the DartPad console, we signal to
    // `window.onerror` that we've already sent a dartMainRunner message by
    // flipping _thrownDartMainRunner to true.  Some platforms don't populate
    // error so avoid using it if it is null.
    //
    // This seems to produce both the stack traces we expect in inspector and
    // the right error messages on the console.
    completeScript.writeln('''
var _thrownDartMainRunner = false;

window.onerror = function(message, url, lineNumber, colno, error) {
  if (!_thrownDartMainRunner) {
    var errorMessage = '';
    if (error != null) {
      errorMessage = 'Error: ' + error;
    } 
    parent.postMessage({
      'sender': 'frame',
      'type': 'stderr',
      'message': message + errorMessage
    }, '*');
  }
  _thrownDartMainRunner = false;
};
''');

    completeScript.writeln(javaScript);

    return completeScript.toString();
  }

  Future<void> _send(String command, Map<String, Object?> params) {
    final message = {
      'command': command,
      ...params,
    };
    _frame.contentWindow!.postMessage(message, '*');
    return Future.value();
  }

  /// Destroy and reload the iframe.
  Future<void> _reset() {
    if (_frame.parent != null) {
      _readyCompleter = Completer();

      final clone = _frame.clone(false) as html.IFrameElement;
      clone.src = _frameSrc;

      final children = _frame.parent!.children;
      final index = children.indexOf(_frame);
      children.insert(index, clone);
      _frame.parent!.children.remove(_frame);
      _frame = clone;
    }

    return _readyCompleter.future.timeout(const Duration(seconds: 1),
        onTimeout: () {
      if (!_readyCompleter.isCompleted) _readyCompleter.complete();
    });
  }

  void _initListener() {
    html.window.addEventListener('message', (event) {
      if (event is html.MessageEvent) {
        final data = (event.data as Map).cast<String, dynamic>();
        if (data['sender'] != 'frame') {
          return;
        }
        final type = data['type'] as String?;

        if (type == 'stderr') {
          // Ignore any exceptions before the iframe has completed
          // initialization.
          if (_readyCompleter.isCompleted) {
            _stdoutController.add(data['message'] as String);
          }
        } else if (type == 'ready' && !_readyCompleter.isCompleted) {
          _readyCompleter.complete();
        } else if (data['message'] != null) {
          _stdoutController.add(data['message'] as String);
        }
      }
    }, false);
  }
}
